# 现代操作系统：原理与实现

## 硬件结构

冯诺伊曼结构包括三个主要部分。

- 中央处理单元（Central Processing Unit，CPU）：主要负责运算和逻辑控制。按照程序中的指令进行计算，并且根据条件执行程序中的不同部分（顺序或跳转执行）。

- 存储器（memory unit）：负责存储程序指令和数据，以及保存程序执行的中间结果和最终结果。在现代计算机中’存储器通常包括寄存器、CPU缓存、内存等存储层次。
- 输入输出（Input and Output，I/O）：负责与外界进行交互，从外界获得输入，将结果向外界输出。诸如键盘、鼠标、显示器、打印机以及网卡等外设，都属于此类设备。

![2022-08-05 10-22-54 的屏幕截图](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap2硬件结构/2022-08-05 10-22-54 的屏幕截图.png)

### CPU与指令集架构

指令集架构（Instruction Set Architecture，ISA）是CPU和软件之间的桥梁。ISA包含指令集、特叹级、寄存器、执行模式、安全扩展、性能加速扩展等诸多方面。

#### 指令集

通常包含—系列不同功能的指令，用于数据搬移、计算、内存访问、过程调用等。

本书选择AArch64体系结构作为介绍操作系统的主要平台，其指令集属于精简指令集计算机（Reduced Instruction Set Computer，RISC）。AArch64中每条指令的长度固定为4字节，指令类型包括：

- 数据搬移指令（如mov）；
- 寄存器计算指令（如加法指令己add、减法指令sub）；
- 内存读写指令（如内存加载指令ldr、内存写入指令str）；
- 跳转指令（如无条件跳转指令b）；
- 过程调用指令（如调用指令bl、返回指令ret）；
- 特权指令（如读取系统寄存器指令msr、写人系统寄存器指令mrs）等。

#### 特权级

特权级也是ISA的重要组成部分。AArch64中的特权级被称为异常级别（Exception Level， EL），共有四种特权级。

![2022-08-05 10-32-55 的屏幕截图](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap2硬件结构/2022-08-05 10-32-55 的屏幕截图.png)

- EL0：最低的特权级，应用程序通常运行在该特权级，也称为用户态。
- EL1：操作系统通常运行在该特权级，也称为内核态。
- EL2:在虚拟化场景下需要，虚拟机监控器（Virtual Machine Monitor，VMM，也称为Hypervisor）通常运行在该特权级。
- EL3：和安全特性TrustZone相关，负责普通世界（normal world）和安全世界（secure world）之间的切换。

TrustZone是从ARMv6体系结构开始引入的安全特性，如今已被广泛使用。该特性从逻辑上将整个系统分为安全世界和普通世界，计算资源可以被划分到这两个世界中。安全世界可以不受限制地访问所有的计算资源，而普通世界不能访问被划分到安全世界的计算资源。比如说，普通世界不能访问属于安全世界的物理内存和设备。

CPU在提供四种特权级同时提供了特权级之间的切换方式。由于通常应用程序运行在EL0而操作系统运行在EL1所以我们主要介绍EL0与EL1之间的常见切换场景。一般来说，从EL0（应用程序）切换到EL1（操作系统）的可能场景有三种:

1.应用程序需要调用操作系统提供的系统调用，此时应用程序会通过执行SVC（特权调用，supervisor call）指令将CPU特权级从EL0切换到EL1。

2.应用程序执行了一条指令，而该指令触发了异常（exception），该异常导致CPU特权级从EL0切换到EL1。例如，应用在执行一条访存指令时，触发了缺页异常（page fault），从而切换到操作系统内核进行处理。

3.应用程序在执行的过程中，CPU收到一个来自外设的中断（ interrupt），该中断也会导致CPU特权级从EL0切换到EL1。

前两种场景往往统称为同步的CPU特权级切换，因为它们的特权级切换都是由CPU中正在执行的指令所导致的。在第三种场景下CPU发生的特权级切换并不是由于CPU运行应用程序中的指令而导致的，属于异步的CPU特权级切换。

如图展示了EL0和ELl之间切换的基本流程，该流程通常由CPU和操作系统内核协同完成。具体来说，在发生特权级切换的时刻，CPU负责保存当前执行状态，以便操作系统内核在处理异常时使用并在处理结束后能够恢复应用程序的执行。CPU保存的主要状态包括：

- 触发异常的指令地址（即当前程序计数器（Program Counter，PC）），保存在ELR_EL1（异常链接寄存器，Exception Link Regjster）中;
- 异常原因（即异常是由于执行svc指令还是由于访存缺页导致的），保存在ESR_EL1（异常症状寄存器，Exception Syndrome Register）中;
- CPU将栈指针（Stack Pointer，SP）从SP_EL0（应用程序使用的栈）切换到SP_EL1（操作系统可以通过设置这个寄存器来配置异常处理过程中使用的栈）;
- CPU还会保存一些其他状态，例如将CPU的相关状态保存在SPSR_EL1（巳保存的程序状态寄存器，Saved Program Status Register）中，将引发缺页异常的地址保存在FAR_EL1（错误地址寄存器，Fault Address Register）中。

![2022-08-05 10-48-47 的屏幕截图](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap2硬件结构/2022-08-05 10-48-47 的屏幕截图.png)

操作系统可以在异常向量表中为不同的异常类型配置相应的异常处理函数。因此，当发生特权级切换时，CPU会读取VBAR_EL1（向量基地址寄存器，Vector Base Address Rcgister）来获得异常向量表（exception vector table）的基地址，然后根据异常原因（ESR_EL1中保存的内容）调用操作系统设置的相应异常处理函数。之后，操作系统中的相应异常处理函数开始执行，—般来说该函数会先保存应用程序的上下文（比如通用寄存器）以防止操作系统在执行过程中破坏这些状态，然后会根据异常原因进行相应的处理。例如，若特权级切换是应用程序执行SVC指令导致的，则执行相应的系统调用；若特权级切换是访存过程中缺页异常导致的，则执行相应的缺页异常处理函数。在异常处理完后，操作系统会恢复应用程序的上下文，然后执行eret（异常返回，Exception Return）指令以恢复CPU自动保存的EL0状态（包括PC和SP等），并切回到EL0，使应用程序从被中断出继续执行。

#### 寄存器

寄存器是ISA的另—个重要组成部分。在AArch64中，有31个64位通用寄存器，被命名为X0～X30。其中，X29用作帧指针（Frame Pointer， FP）寄存器，按照使用惯例，—般用于保存函数调用过程中栈顶的地址；X30用作链接指针（Link Pointer，LP）寄存器，因为CPU在执行函数调用指令b1时会自动把返回地址保存在其中。

在EL1特权级下有两个页表基地址寄存器（Translatlon Table Base Register，TTBR），即TTBR0_EL1和TTBR1_EL1它们负责翻译虚拟地址空间中不同的地址段，负责的地址范围由另一个控制寄存器TCR_EL1（翻译控制寄存器，Translation
 Control Register）决定。操作系统中一种常见的配置是TTBR0_EL1负责［0-2的48次方）的地址映射（作为用户地址空间）， TTBR1_EL1负责［2的48次方-2的64次方）的地址映射（作为操作系统内核地址空间）。





