# 现代操作系统：原理与实现

## 操作系统结构

操作系统需要满足—定的设计目标’这些目标可以分为以下两种。

1. 用户目标:方便使用、容易学习、可靠、安全以及流畅等。
2. 系统目标:易于实现与维护、灵活、可靠、不易出错、高效等。

### 操作系统的机制与策赂

如何能有效地控制操作系统设计的复杂度呢？操作系统乃至计算机系统中控制复杂度的—个重要设计原则是：将策略与机制相分离。其中，策赂（policy）表示要”做什么“，机制（mechanism）表示该“如何做”。

通过机制与策略的分离，操作系统—方面可以通过多种不同的策略来适应不同的应用需求，而不需要重新来实现对应的具体机制，另一方面也可以通过持续优化具体的机制以不断完善一个策略的实现。

### 操作系统复杂度管理办法

管理复杂系统的重要方法是M.A.L.H方法，即模块化（modularity）、抽象（abstraction）、分层（layering）和层级（hierarchy）。

模块化：模块化就是通过“分而治之”（divide and conquer）原则，将一个复杂系统分解为一系列通过明确定义的接口进行交互的模块，并严格保障模块之间的界限。划分要充分考虑高内聚和低藕合，使模块具有独立性。

抽象：抽象是在模块化的基础上，将接口与内部实现分离，从而使模块之间只需通过抽象的接口进行相互调用，而无须关心各个模块的内部实现。—个好的抽象应该尽可能依从模块间的自然边界，并尽可能地减少模块间的交互，从而减少错误在模块间的传递，提高整体系统的开发效率、质量与性能等。

良好的模块化与抽象可以很好地将—个大系统分解为一系列能够较妇地进行交互的模块。然而。对于一个大的复杂系统而言，—个可能的结果是分解的模块会非常多，相互的交互关系会非常复杂，因此需要进一步通过分层与层级来控制复杂度。

![2022-09-22_22-10](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-22_22-10.png)

分层:分层是通过将模块按照一定的原则进行层次的划分，约束每层内部模块间的交互方式与跨层次模块间的交互方式，从而有效地减少模块之间的交互。通常的原则是:一个模块只能和同层模块以及相邻的上层或下层模块进行交互，而不能跨—层和再上一层或再下一层的模块进行交互。分层也是构建复杂系统的—个重要的方式：确定层级后，我们可以先构建底层的模块，然后利用底层模块提供的功能与服务进一步构建上层的模块。

层级:层级是另外一种模块的组织方式。首先将—些功能相近的模块组成—个具有清晰接口的自包含子系统，然后再将这些子系统递归地组成—个具有清晰接口的更大子系统。在操作系统中，虚拟内存是一个子模块，与物理内存分配、缺页异常处理、页换入换出等一起构成内存管理模块，内存管理模块再和进程管理模块｀设备驱动模块等一起构成操作系统内核。

分层指不同类型模块之间的层级，层级指同类模块之间的分层。

### 操作系统内核架构

![2022-09-23_08-45](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_08-45.png)

#### 简要结构

一些功能较为简单的操作系统，会选择将应用程序与操作系统放置在同—个地址空间（address space）中，无须底层硬件提供复杂的内存管理、特权级隔离等功能。该结构的—个优势在于，应用程序对操作系统服务的调用可直接通过函数诡用高效完成，但缺点也同样明显，任何一个应用或操作系统模块出现了问题，均有可能使整个系统崩溃。

![2022-09-23_08-49](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_08-49.png)

除了MSDOS外，当前采用简要结构的操作系统还包括FreeRTOSG与uCOS等。这些操作系统主要运行在微控制单元（MicroController Unit，MCU）等相对比较简单的硬件上，这些硬件通常没有提供现代意义上的内存管理单元（Memory Management Unit，MMU），隔离能力较弱或缺失，难以运行（往往也不需要运行）复杂的操作系统。

#### 宏内核架构

宏内核（Monolithic kernel）又称单内核，其特征是操作系统内核的所有模块（包括进程调度、内存管理、文件系统、设备驱动等）均运行在内核态，具备直接操作硬件的能力，这类操作系统包括UNIX、Linux、FreeBSD等。

1. 模块化：现代操作系统（如UNIX、Linux、Windows等）的内核均采用模块化的策略来组织各各功能。为进一步提高功能的可扩展性，现代操作系统通常还提供了可加载内核模块（Loadable kernel Module,LKM）机制。例如，当前大部分设备驱动是以可加载模块的形式存在的，与内核其他模块解耦，使驱动开发与驱动加载更加方便、灵活。
2. 抽象：现代操作系统内核均广泛采用抽象的方法来降低复杂度并提高可维护性。UNIX将文住作为一个重要的抽象，提出一切皆是文件（everything is a file），将数据、设备、内核对象等均抽象为文件，并为上层应用提供统一的接口。
3. 分层：宏内核架构的操作系统一开始就采用了分层的架构。
4. 层级：层级的概念同样被广泛应用于内核的资源管理中，如调度子系统中对进程优先级的分类，控制组（c group）对进程层级的分类，内存分配器对不同内存的分类等。

![2022-09-23_08-58](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_08-58.png)

在一个庞大的系统中进行创新也变得越来越困难，这使得一些较大的创新（如网络、文件系统、设备驱动等）开始往用户态迁移。

#### 微内核架构

随着宏内咳操作系统的内核功能不断增长，系统的复杂度也持续增加，在可靠性、安全性等方面导致了更多的问题。这是因为在宏内核架构下，所有内核模块均运行在特权空间，一个单点的错误就可能会导致整个系统崩溃或者被攻破。

因此，研究人员尝试对宏内核架构的操作系统进行解藕，将单个功能或模块（如文件系统、设备驱动等）从内核中拆分出来，作为一个独立的服务部署到独立的运行环境中；内核仅保留极少的功能，为这些服务提供通信等基础能力，使其能够互相协作以完成操作系统所必需的功能。这种架构被称为微内核（Micro kernel）。

微内核的最小化原则:一个操作系统内核的功能只有在将其放在内核态以外会影响整个系统的功能时，才能被放置在内核态。

![2022-09-23_09-17](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_09-17.png)

![2022-09-23_09-18](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_09-18.png)



#### 外核架构

操作系统内核在硬件管理方面的两个主要功能是资源抽象与多路复用（multiplexing）。其中，对硬件资源的抽象存在两方面的问题：

1. 过度的硬件资源抽象可能会带来较大的性能损失，违反“抽象但不隐藏能力”（abstract but don’t hide power）原则；
2. 操作系统所提供的硬件资源抽象是针对所有应用的通用抽象，这些抽象对一些具体的应用（如数据库、Web服务器等）来说往住不是最优的选择。

因此MIT的Dawson Engler和Frans Kaashoek等研究者于1995年提出了外核（Exokernel）架构。提出了库操作系统（LibOS）的概念，将对硬件的抽象封装到LibOS中，与应屎直接链接，降低应用开发的复杂度；而操作系统内核则只负责对硬件资源在多个库操作系统之间的多路复用的支持，并管理这些LibOS的生命周期。

外核架构可为不同的应用提供定制化的高效资源管理：按照不同应用领域的要求，将对硬件资源的抽象模块化为一系列的库（即LibOS）。这样的设计带来两个主要好处：

1. 可按照应用领域的特点与需求，动态组装成最适合该应用领域的LibOS，最小化非必要的代码，而获得更高的性能；
2. 处于硬件特权级的操作系统内核可以以做到非常小，并且由于多个LibOS之间的强隔离性，从而可以提升整个计算机系统的安全性与可靠性。

![2022-09-23_09-43](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_09-43.png)

对时延要求和性能要求高的嵌入式使用了外核，云计算平台的容器使用了外核。

外核架构的劣势在于:：LibOS通常是为某种应用定制的，缺乏跨场景的通用性，应用生态差。

![2022-09-23_09-46](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_09-46.png)

![2022-09-23_09-46_1](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_09-46_1.png)

#### 其他操作系统内核架构

##### 多内核（Multikernel）架构

当前的硬件结构呈现出两个主要特性：首先，多核乃至众核架构的流行使得—个服务器中通常存在成百上千个处理器核；其次，Dennard缩微定律的终结以及应用需求的多样化使得处理器走向异构化，甚至是动态异构化，也就是—个处理器上可能集成多种功能、性能甚至指令集结构各异的处理器核。

基于硬件的众核与异构特性。Multikernel的想法是将—个众核系统看成一个由多个独立处理器核通过网络互联而成的分布式系统。Multikernel在每个CPU核上运行—个独立的操作系统节点，节点间的交互由操作系统节点之上的进程间通信来完成。通过这种架构，Multikernel可以避免传统操作系统架构中的复杂的隐式共享所带来的性能可扩展性瓶颈，并且由于不同处理器核上运行的操作系统节点是独立的而且可以是不同的，从而非常容易支持异构处理器架构。

![2022-09-23_10-15](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_10-15.png)

##### 混合内核架构

虽然Linux内核是公认的宏内核架构，但其近期也开始融合了微内核架构中的用户态驱动模型（如UIO与VFIO等）。图展示了当前主流的—些操作系统欲架构及其演进以及在现实操作系统中的体现。苹果操作系统内核XNU是一个Mach微内核与BSDUNIX的混合体，被使用于MacOSX中。WmdowsNT的操作系统内核也采用了微内核设计思想，但是将一些系统服务运行在内核态。

![2022-09-23_10-19](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_10-19.png)





### 操作系统框架结构

#### Android系统框架

![2022-09-23_11-26](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_11-26.png)

硬件抽象层（hardware abstract layer）。Android在Linux内核上提供—层硬件抽象层的主要原因有两个：首先，Linux的宏内核架构属性使得设备驱动通常运行在Linux内核态，因此设备驱动的接口依赖于Linux内核设备驱动接口的演进，从而与某个Linux内核版本的实现产生耦合，这会阻碍Android系统框架的独立演进与升级；其次，Linux内核采用了GPLv2开源协议，协议要求运行在同—个地址空间的设备驱动必须开放源码，这会导致一些硬件的实现细节也被公开，因此—些设备厂商担心其硬件竞争力受到影响。因此，Android提供了硬件抽象层，封装了一些硬件实现的细节，从而更好地实现Linux内核与Android系统框架的解耦；并通过提供用户态驱动模型，使得设备厂商不需要开放源码就能为Android操作系统提供设备驱动，从而促使更多的设备厂商加入Android生态。

Android库（Android library）。Android库一方面提供了—些方便Android应用开发的自定义库，另外—方面也重新实现了—些标准库（如glibc等），从而规避了LGPL开源协议。

Android运行环境（Android Run Time，ART）。由于Android应用的主要开发语言是Java，因此需要一个运行时环境将应用从字节码转化为可执行代码。

Android应用框架（Android application framework）。Android应用框架提供了应用运行所需要的基础服务，包括服务管理（service manager）、活动管理（activity manager）、包管理（package manager）、窗口管理（window manager）等。

##### 服务化架构与Binder IPC

Android系统框架的设计整体应用了类似微内核架构的思想，将系统框架组件化与服务化，各个组件依赖于Android提供的Binder IPC进行通信。

![2022-09-23_11-36](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_11-36.png)





服务管理组件负责各个服务组件的注册与管理，应用通过服务管理组件进行服务发现，然后调用各个服务组件请求服务。所有的通信都是通过Binder IPC完成的。通过类似微内核架构的服务化框架，Android将各种不同的服务进行解藕，显著提升了系统的可扩展性与可维护性，并为应用开发提供了较为方便的接口。

#### ROS系统框架

ROS是Robot Operating System的缩写，即机器人操作系统。虽然名字中包含操作系统，但ROS实际上是一个面向机器人硬件场景的系统框架，可运行在Linux内核以及其他兼容POSIX接口的操作系统内核之上。作为—个操作系统的系统框架，ROS提供了一系列面向机器人场景应用的系统级服务，抽象了底层复杂的异构硬件资源，还提供了应用之间交互以及应用与服务之间交互的IPC机制。

![2022-09-23_11-42](/home/cccmmf/操作系统/现代操作系统：原理与实现/chap3操作系统结构/2022-09-23_11-42.png)

##### ROS节点与计算图

ROS采用计算图的形式来组织各种服务。每个服务构成—个节点，每个节点执行一个具体的计算处理、包括机器人中所需的感知、融合、规划与控制等。运行在ROS上的应用可以被表示成一个“图”的架构，不同的节点表示不同的应用（它们既可以是信息接收者，也可以是信息发布者）。ROS上常见的应用包括：接收、发布、处理来自传感器（sensor）的数据，以及对处理过程进行控制的节点与计划节点等。

与微内核设计的思想类似，ROS同样将其系统框架分解为多个服务，不同的服务之间通过ROS提供的IPC进行通信。这种解藕式的架构使得ROS易于部署，甚至可以部署在一个分布式系统上。

##### 服务与动作

ROS每个组件的设计是以服务为中心的：一个服务接收—个请求，执行该请求’然后回复。—个节点可以向另一个提供服务的节点发送请求，然后等待一个结果。服务的模型是—次性拘同步通信，即当服务的请求和回复完成后，连接会被断开；进行下—次交互必须再次建立连接。—个节点还可以提供动作（action）。动作和服务类似，主要的区别在于动作的假设是服务端处理请求的时间会很长，并且可能需要在处理的过程中就获取—些中途的返回值。

##### 话题

话题的方式是ROS中比较新的处理方式，是—类单向的异步通信机制。话题机制将通信的双方称为发布者（publisher）和订阅者（subscriber）。发布者节点首先需要向主节点（一个特殊的全局节点）注册—个话题，之后该发布者会以消息的形式发布关于该话题的新内容。希望接收该话题的订阅者节点则通过主节点获得对应话题的发布者发布的信息；基于这个信息，订阅者节点可以直接连接到发布者节点，来接收最新的话题消息。在话题的模式下，发布者和订阅者是多对多的关系，即单个节点可以成为多个话题的发布者，也可以成为多个话题的订阅者。

##### 数据分发服务

ROS20引入了数据分发服务（Data Distribution Service，DDS）以支持实时性，从架构的角度DDS可以被看作一个系统中间件，处于ROS应用层和ROS基础设施层之间。DDS提供了上面介绍的ROS基本通信接口和语义，如话题方式的发布者和订阅者模型或服务类型的IPC等。之所以将DDS分离出来，是为了将对性能有重要影响的通信进行加速。不同的硬件厂商可以针对自己的机器人环境实现DDS的中间件，只要最终这些DDS的实现能够满足对应的协议接口即可。而这些DDS的实现由于是针对特定硬件进行的，因此可以进行针对性的优化。这样一来，ROS的应用只需要考虑DDS的抽象，而不需要考虑底层硬件的细节，便可以使用当前环境下最高效的通信方式。

有了DDS抽象后，在ROS2.0中可以抛弃ROS中基于主节点的服务发现方式。这依赖于DDS提供的—套分布式发现系统（distributed discovery system），避免在主节点上出现性能瓶颈。ROS需要通过DDS提供的API接口来获取诸如当前存活的节点、当前的话题、当前注册的动作等信息。对于这些信息的查询都被ROS进行了抽象，对ROS上的应用而言其实是透明的。

DDS内部可以利用共享内存的方式来传递本地数据。在ROS1.0中，从系统底层来看，一次消息传输是先序列化数据，然后通过TCP（send）的方式把数据传递出去。这中间更多的考虑是兼容性等，即使是本地的数据也会通过本地的localhost等接口进行传输。而在ROS2.0中，ROS会将数据交接给DDS层。在DDS层中，具体的DDS实现可以使用一些如共享内存的方式，在建立了连接的不同节点之间共享数据。在传输后，可以直接将序列化后的数据放在共享区域中，这样可以极大地提升传输性能。

##### 计算图架构与ROS IPC

ROS系统框架的设计将计算任务组件化与服务化，形成独立的ROS节点；各个节点通过ROS IPC（如话题、服务、动作等方式）进行通信。DDS的引人能够在支持多种通信方式的情况下，尽可能地优化底层通信性能。这些设计充分体现了机制与策略分离的原则。类微内核设计的解耦式架构使得ROS系统框架及其应用易于部署在硬件环境差异极大的机器人平台上，并且显著提升了单个节点的可复用能力。
